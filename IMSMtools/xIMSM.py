import xarray as xr
import os
import glob
import numpy as np
from numpy.polynomial.legendre import legcompanion, legder, legval
import numpy.linalg as la

def open_mfdataset(paths, **kwargs):
    """
    Wrapper for xarray.open_mfdataset

    Parameters
    ----------
    paths : str or sequence
        Files to open (see documentation for xarray.open_mfdataset)
    **kwargs : optional
        Additional keyword arguments for xarray.open_mfdataset
        
    Returns
    -------
    dset : xarray.Dataset
        Dataset object containing coordinates, variables, and grid metadata
    """

    # Open files
    dset = xr.open_mfdataset(paths, **kwargs)
    return dset

def gglat(nlat, nnewton = 5):
    """
    Compute and return latitudes on a Gaussian grid.
    Based on https://gist.github.com/ajdawson/b64d24dfac618b91974f.

    Parameters
    ----------
    nlat: int
        Number of latitude points

    Keyword arguments
    -----------------
    nnewton: int, default 5
        Number of Newton iterations used to improve roots

    Returns
    -------
    array-like
        Gaussian grid latitudes
    """
    assert (nlat > 0 and nlat % 2 == 0), 'nlat must be positive and even'

    # Generate companion matrix
    coef = np.array([0]*nlat + [1], dtype = np.int)
    com = legcompanion(coef)

    # Calculate roots
    roots = la.eigvalsh(com)
    roots.sort()
    for _ in range(nnewton):
        f = legval(roots, coef)
        df = legval(roots, legder(coef))
        roots -= f/df

    # Ensure symmetry
    roots = (roots - roots[::-1]) / 2.0
    return np.arcsin(roots) * 180.0 / np.pi


from scipy.interpolate import interp2d

indir = '/nfs/twcroninlab002/thabbott/IMSM/idealized_moist_mtdiag/T42/INPUT'
outdir = '/nfs/twcroninlab002/thabbott/IMSM/idealized_moist_mtdiag/T85interp/INPUT'

def upsample_input_files(indir, outdir):
    """
    Upsample input files from low-resolution simulations for hot-starting
    a high-resolution simulation. This function produces upsampled files
    with '.interp' appended to the file names. As of now (11/10/2019) the
    function only supports changing horizontal resolution, and the code needs
    some refactoring (a lot of components are repeated...).

    Parameters
    ----------
    indir: str
        Path to directory containing low-resolution restart files

    outdir: str
        Path to directory containing high-resolution restart files. These
        are required to determine the dimensions of the grid onto which the
        low-resolution fields are interpolated and can be generated by
        running the high-resolution model from a cold start for a single
        time step.
    """
    ###
    # handle atmosphere.res.nc
    ###
    f = 'atmosphere.res.nc'
    interp_vars = ['ug', 'vg', 'tg', 'psg', 'sphum', 'wg_full']
    lon = 'xaxis_2'
    lat = 'yaxis_2'
    
    # Load datasets
    dsetin = open_mfdataset('%s/%s' % (indir, f), decode_cf = False)
    dsetout = open_mfdataset('%s/%s' % (outdir, f), decode_cf = False)
    
    # Generate lat-lon grids
    latin = gglat(dsetin[lat].size)
    lonin = np.linspace(0.0, 360.0, dsetin[lon].size + 1)
    latout = gglat(dsetout[lat].size)
    lonout = np.arange(0.0, 360.0, 360.0/dsetout[lon].size)
    
    for v in dsetin.data_vars:
        
        # Skip if no interpolation dimensions are included
        if not v in interp_vars:
            print('Skipping %s' % v)
            continue
        
        # Load arrays for interpolation
        arrin = dsetin[v].values
        arrout = dsetout[v].values
        
        # Wrap around in longitude
        arrin = np.concatenate((arrin, arrin[:,:,:,0][...,np.newaxis]), axis = 3)
        
        # Interpolate
        for ii in range(arrout.shape[0]):
            for jj in range(arrout.shape[1]):          
                interpolate = interp2d(lonin, latin, arrin[ii,jj,:,:].squeeze())
                arrout[ii,jj,:,:] = interpolate(lonout, latout)
        
        # Update data in output dataset
        dsetout[v].values = arrout
        
    # Write changes to output dataset
    print('Writing changes to %s.interp' % f)
    dsetout.to_netcdf(path = '%s/%s.interp' % (outdir, f))
    
    ###
    # handle mixed_layer.res.nc
    ###
    f = 'mixed_layer.res.nc'
    interp_vars = ['t_surf']
    lon = 'xaxis_1'
    lat = 'yaxis_1'
    
    # Load datasets
    dsetin = open_mfdataset('%s/%s' % (indir, f), decode_cf = False)
    dsetout = open_mfdataset('%s/%s' % (outdir, f), decode_cf = False)
    
    # Generate lat-lon grids
    latin = gglat(dsetin[lat].size)
    lonin = np.linspace(0.0, 360.0, dsetin[lon].size + 1)
    latout = gglat(dsetout[lat].size)
    lonout = np.arange(0.0, 360.0, 360.0/dsetout[lon].size)
    
    for v in dsetin.data_vars:
        
        # Skip if no interpolation dimensions are included
        if not v in interp_vars:
            print('Skipping %s' % v)
            continue
        
        # Load arrays for interpolation
        arrin = dsetin[v].values
        arrout = dsetout[v].values
        
        # Wrap around in longitude
        arrin = np.concatenate((arrin, arrin[:,:,:,0][...,np.newaxis]), axis = 3)
        
        # Interpolate
        for ii in range(arrout.shape[0]):
            for jj in range(arrout.shape[1]):          
                interpolate = interp2d(lonin, latin, arrin[ii,jj,:,:].squeeze())
                arrout[ii,jj,:,:] = interpolate(lonout, latout)
        
        # Update data in output dataset
        dsetout[v].values = arrout
        
    # Write changes to output dataset
    print('Writing changes to %s.interp' % f)
    dsetout.to_netcdf(path = '%s/%s.interp' % (outdir, f))
    
    ###
    # handle spectral_dynamics.res.nc
    ###
    
    f = 'spectral_dynamics.res.nc'
    interp_vars = ['ug', 'vg', 'tg', 'psg', 'sphum', 'vorg', 'divg', 'surf_geopotential']
    spec_vars = ['vors_real', 'vors_imag', 'divs_real', 'divs_imag', 'ts_real', 'ts_imag', 'ln_ps_real', 'ln_ps_imag']
    lon = 'xaxis_4'
    lat = 'yaxis_3'
    spx = 'xaxis_3'
    spy = 'yaxis_2'
    
    # Load datasets
    dsetin = open_mfdataset('%s/%s' % (indir, f), decode_cf = False)
    dsetout = open_mfdataset('%s/%s' % (outdir, f), decode_cf = False)
    
    # Generate lat-lon grids
    latin = gglat(dsetin[lat].size)
    lonin = np.linspace(0.0, 360.0, dsetin[lon].size + 1)
    latout = gglat(dsetout[lat].size)
    lonout = np.arange(0.0, 360.0, 360.0/dsetout[lon].size)
    
    for v in dsetin.data_vars:
        
        # Skip if no interpolation dimensions are included
        if not (v in interp_vars or v in spec_vars):
            print('Skipping %s' % v)
            continue
        
        # Load arrays for interpolation
        arrin = dsetin[v].values
        arrout = dsetout[v].values
        
        # Handle gridpoint variables
        if v in interp_vars:
            
            # Wrap around in longitude
            arrin = np.concatenate((arrin, arrin[:,:,:,0][...,np.newaxis]), axis = 3)
    
            # Interpolate
            for ii in range(arrout.shape[0]):
                for jj in range(arrout.shape[1]):          
                    interpolate = interp2d(lonin, latin, arrin[ii,jj,:,:].squeeze())
                    arrout[ii,jj,:,:] = interpolate(lonout, latout)
                    
        # Handle spectral variables
        elif v in spec_vars:
            
            # Add data to low modes; leave high modes at 0
            for ii in range(arrout.shape[0]):
                for jj in range(arrout.shape[1]):
                    arrout[ii,jj,:,:] = 0.0
                    arrout[ii,jj,:arrin.shape[2],:arrin.shape[3]] = arrin[ii,jj,:,:]
        
        # Update data in output dataset
        dsetout[v].values = arrout
        
    # Write changes to output dataset
    print('Writing changes to %s.interp' % f)
    dsetout.to_netcdf(path = '%s/%s.interp' % (outdir, f))
